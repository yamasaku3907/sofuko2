<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="keywords" content="Aoki,Atsushi,Smalltalk,Smalltalker,Program,Programmer,Object,Oriented,Programming">
<meta name="description" content="ソフトウェア工学IIのホームページ">
<meta name="author" content="AOKI Atsushi">
<link rev="made" href="index.html">
<link rel="index" href="index.html">
<style type="text/css">
<!--
body {
  background-color : #ffffff;
  margin : 20px;
  padding : 10px;
  font-family : serif;
  font-size : 10pt;
}
a {
  text-decoration : underline;
  color : #000000;
}
a:link {
  background-color : #ffddbb;
}
a:visited {
  background-color : #ccffcc;
}
a:hover {
  background-color : #dddddd;
}
a:active {
  background-color : #dddddd;
}
div.belt {
  background-color : #eeeeee;
  padding : 0px 4px;
}
div.belt-yellow {
  background-color : #ffffcc;
  padding : 0px 4px;
}
div.belt-blue {
  background-color : #ddeeff;
  padding : 0px 4px;
}
div.right-small {
  text-align : right;
  font-size : 8pt;
}
img.border {
  border-width : 1px;
  border-color : #000000;
  vertical-align : middle;
}
img.borderless {
  border-width : 0px;
  vertical-align : middle;
}
p.belt {
  background-color : #ffeedd;
  padding : 4px 8px;
}
p.belt-blue {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt-yellow {
  background-color : #ffffcc;
  padding : 4px 8px;
}
table {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
}
table.profile {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
  margin-top : 8px;
  margin-left : 8px;
  margin-right : 8px;
  margin-bottom : 8px;
}
table.belt {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  background-color : #ffeedd;
  padding : 0px 0px;
  width : 100%;
}
table.content {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
}
table.font-fixed {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
  font-family : monospace;
}
table.nest {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 0px 0px;
}
td {
  padding : 0px 0px;
  vertical-align : middle;
}
td.center {
  text-align : center;
}
td.center-half {
  text-align : center;
  width : 50%;
  font-size : 8pt;
}
td.center-small {
  text-align : center;
  font-size : 8pt;
  padding : 0px 4px;
}
td.center-small-nopadding {
  text-align : center;
  font-size : 8pt;
  padding : 0px 0px;
}
td.center-white {
  text-align : center;
  background-color : #ffffff;
}
td.center-small-white {
  text-align : center;
  font-size : 8pt;
  background-color : #ffffff;
}
td.center-border1 {
  text-align : center;
  vertical-align : middle;
  empty-cells : show;
  border-style : solid;
  border-width : 1px;
  border-color : #ffc080;
  width : 22px;
  height : 22px;
}
td.left-small {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
}
td.left-small-white {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
td.right-small {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
}
td.right-small-white {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
th {
  padding : 0px 0px;
  vertical-align : middle;
}
#menu {
  margin: 0px 0px 0px 0px;
  padding: 0px;
  height: 32px;
}
#menu ul {
  margin: 0px;
  padding: 0px;
  list-style: none;
  text-align: center;
  clear: both;
}
#menu li {
  margin: 0px 5px 0px 0px;
  padding: 0px;
  float: left;
}
#menu a {
  display: block;
  padding: 2px 4px;
  text-decoration: none;
  margin: 0px;
  font-weight: bold;
  background: #FFFFFF;
  color: #333333;
  border: 1px solid #666666;
}
#menu a:hover {
  display: block;
  padding: 2px 4px;
  border-bottom: 1px solid #000000;
  text-decoration: none;
  background: #FFCC66;
}
#menu .current {
  background-color: #F45F57;
  font-weight: bold;
  color: #FFFFFF;
  border: 1px solid #333333;
}
-->
</style>
<title>ソフトウェア工学II「樹状整列」プログラム</title>
</head>
<body>
<div id="menu">
<ul>
  <li><a href="../index.html">ホーム</a></li>
  <li><a href="../Requirement/index.html">要求仕様書</a></li>
  <li><a href="../DevelopmentPlan/index.html">開発計画書</a></li>
  <li><a href="../BasicDesign/index.html">基本設計書</a></li>
  <li><a href="../DetailDesign/index.html">詳細設計書</a></li>
  <li><a href="../TestSpecification/index.html">テスト仕様書</a></li>
  <li><a href="../TestResult/index.html">テスト結果</a></li>
  <li><a href="../DevelopmentResult/index.html">開発実績</a></li>
  <li><a href="../Program/index.html" class="current">プログラム</a></li>
  <li><a href="../Manual/index.html">マニュアル</a></li>
</ul>
</div>
<hr>
<h2>ソフトウェア工学II「樹状整列」プログラム</h2>
<div class="belt">
<h3><a name="KanseiSaseteKudasai">プログラム一覧</a></h3>
</div>
<ul>
  <li><a href="#Constants">Constants</a>（定数）
  <li><a href="#Example">Example</a>（メインクラス）
  <li><a href="#SpiroModel">SpiroModel</a>（モデル）
  <li><a href="#SpiroView">SpiroView</a>（ビュー）
  <li><a href="#SpiroController">SpiroController</a>（コントローラ）
  <li><a href="#Forest">Forest</a>（フォレスト）
  <li><a href="#Branch">Branch</a>（ブランチ）
  <li><a href="#Node">Node</a>（ノード）
</ul>
<ul>
  <li><a href="#forest.mf">forest.mf</a>（マニフェストファイル）
  <li><a href="#Makefile">Makefile</a>（メイクファイル）
  <li><a href="#build.xml">build.xml</a>（ビルドファイル）
</ul>
<div class="belt">
  <h3><a name="Constants">Constants (定数)</a></h3>
</div>
<pre>
package forest;

import java.awt.Color;
import java.awt.Font;
import java.awt.Point;

public class Constants {
	/**
	 * このクラスはインスタンスを生成する必要がないため、コンストラクタをprivateにしています。
	 */
	private Constants() {
	}

	/**
	 * 樹状整列データファイル中のタグ「ツリー」を表します。
	 */
	public static final String TagOfTrees = "trees:";

	/**
	 * 樹状整列データファイル中のタグ「ノード」を表します。
	 */
	public static final String TagOfNodes = "nodes:";

	/**
	 * 樹状整列データファイル中のタグ「ブランチ」を表します。
	 */
	public static final String TagOfBranches = "branches:";

	/**
	 * ノードを描く際のラベルの文字色を表します。
	 */
	public static final Color ForegroundColor = Color.BLACK;

	/**
	 * ノードを描く際のラベルの背景色を表します。
	 */
	public static final Color BackgroundColor = Color.WHITE;

	/**
	 * ノードを描く際のラベルのフォントを表します。
	 */
	public static final Font DefaultFont = new Font("Serif", Font.PLAIN, 12);

	/**
	 * ノードにおいてラベルを描く際の枠縁から余裕 (マージン) を表します。
	 */
	public static final Point Margin = new Point(4, 2);

	/**
	 * ノード群を樹状に整列させる際にノード同士の間隔を表します。
	 */
	public static final Point Interval = new Point(25, 2);

	/**
	 * ノード群を深さ優先にたどる際の状態「未定」を表します。
	 */
	public static final Integer UnKnown = Integer.valueOf(0);

	/**
	 * ノード群を深さ優先にたどる際の状態「未訪問」を表します。
	 */
	public static final Integer UnVisited = Integer.valueOf(1);

	/**
	 * ノード群を深さ優先にたどる際の状態「訪問済」を表します。
	 */
	public static final Integer Visited = Integer.valueOf(2);

	/**
	 * 樹状整列アニメーションのチックタック: 時間間隔: スピードを表します。
	 * (ミリ秒単位)
	 */
	public static final Integer SleepTick = Integer.valueOf(50);
}

</pre>
<div class="belt">
  <h3><a name="Example" href="../TestSpecification/index.html#Example">Example (メインクラス)</a></h3>
</div>
<pre>
package forest;

import java.awt.Dimension;
import java.awt.Point;
import java.io.File;
import javax.swing.JFrame;

/**
 * 樹状整列の例題クラス：使い方の典型を示すのが目的のプログラムです。<br>
 * Makefileを用いた実行方法は以下の通りです。<br>
 * $ make tree # 木を整列描画<br>
 * $ make forest # 森を整列描画<br>
 * $ make semilattice # 亜格子状の森を整列描画<br>
 */
public class Example extends Object {
	/**
	 * 第1引数で樹状整列データファイルを受け取って樹状整列を実行します。<br>
	 * $ java -Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar forest.jar
	 * resource/data/tree.txt<br>
	 * $ java -Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar forest.jar
	 * resource/data/forest.txt<br>
	 * $ java -Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar forest.jar
	 * resource/data/semilattice.txt<br>
	 * 
	 * @param arguments 樹状整列データファイルを第1引数とする引数文字列群
	 */
	public static void main(String[] arguments) {
		// 引数が無い（樹状整列データファイルの在り処がわからない）をチェックする。
		if (arguments.length < 1) {
			System.err.println("There are too few arguments.");
			System.exit(1);
		}

		// 第1引数で指定された樹状整列データファイルの存在をチェックする。
		File aFile = new File(arguments[0]);
		if (!(aFile.exists())) {
			System.err.println("'" + aFile + "' does not exist.");
			System.exit(1);
		}

		// MVCを作成する。
		SpiroModel aModel = new SpiroModel(aFile);
		SpiroView aView = new SpiroView(aModel);

		// ウィンドウを生成して開く。
		JFrame aWindow = new JFrame(aFile.getName());
		aWindow.getContentPane().add(aView);
		aWindow.setMinimumSize(new Dimension(400, 300));
		aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		aWindow.setSize(800, 600);
		aWindow.setLocationRelativeTo(null);
		aWindow.setVisible(true);

		// 樹状整列のアニメーションを行う。
		aModel.animate();

		return;
	}
}
</pre>
<div class="belt">
  <h3><a name="SpiroModel" href="../TestSpecification/index.html#SpiroModel">SpiroModel (モデル)</a></h3>
</div>
<pre>
package forest;

import java.io.File;
import java.util.ArrayList;
import mvc.Model;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.swing.SwingUtilities;

/**
 * 樹状整列におけるMVCのモデル (M) を担うクラスになります。
 */
public class SpiroModel extends Model {

    /**
     * 樹状整列それ自身を記憶しておくフィールドです。
     */
    private Forest forest;

    /**
     * このクラスのインスタンスを生成するコンストラクタです。
     * 
     * @param aFile 樹状整列データファイル
     */
    public SpiroModel(File aFile) {
        super();
        this.read(aFile);
        if (this.forest != null) {
            this.arrange();
        }
    }

    /**
     * アニメーションを行うメソッドです。
     */
    public void animate() {
        if (this.forest == null)
            return;
        this.forest.arrange(this);
        this.changed();
    }

    /**
     * 樹状整列を行うメソッドです。
     */
    public void arrange() {
        if (this.forest == null)
            return;
        this.forest.arrange();
        this.changed();
    }

    /**
     * 自分自身が変化したことを依存物たちに放送 (updateを依頼) するメソッドです。
     */
    @Override
    public void changed() {
        SwingUtilities.invokeLater(() -> {
            super.changed(); // これがViewのupdate() -> repaint()を呼び出します
        });
    }

    /**
     * 樹状整列それ自身を応答するメソッドです。
     * 
     * @return 樹状整列それ自身
     */
    public Forest forest() {
        return this.forest;
    }

    /**
     * 樹状整列データファイルから樹状整列それ自身を生成するメソッドです。
     * 
     * @param aFile 樹状整列データファイル
     */
    protected void read(File aFile) {
        this.forest = new Forest();
        Map<String, Node> nodeMap = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader(aFile))) {
            String line;
            String currentSection = "";
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith(Constants.TagOfTrees)) {
                    continue;
                }

                if (line.equalsIgnoreCase(Constants.TagOfNodes)) {
                    currentSection = Constants.TagOfNodes;
                    continue;
                } else if (line.equalsIgnoreCase(Constants.TagOfBranches)) {
                    currentSection = Constants.TagOfBranches;
                    continue;
                }

                String[] parts = line.split(",", 2);
                if (parts.length < 2)
                    continue;

                if (currentSection.equals(Constants.TagOfNodes)) {
                    String id = parts[0].trim();
                    String name = parts[1].trim();
                    Node node = new Node(name);
                    nodeMap.put(id, node);
                    this.forest.addNode(node);
                } else if (currentSection.equals(Constants.TagOfBranches)) {
                    Node fromNode = nodeMap.get(parts[0].trim());
                    Node toNode = nodeMap.get(parts[1].trim());
                    if (fromNode != null && toNode != null) {
                        this.forest.addBranch(new Branch(fromNode, toNode));
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
            this.forest = null; // 読み込み失敗
        }
    }

    /**
     * 樹状整列の根元 (ルート) になるノードを探し出して応答するメソッドです。
     * 
     * @return ルートノード、ただし、見つからないときはnull
     */
    public Node root() {
        if (this.forest == null)
            return null;
        ArrayList<Node> roots = this.forest.rootNodes();
        return roots.isEmpty() ? null : roots.get(0);
    }

    /**
     * 樹状整列の根元(ルート)になるノードたちを探し出して応答するメソッドです。
     * 
     * @return ルートノードたち、ただし、見つからないときは空リスト
     */
    public ArrayList<Node> roots() {
        if (this.forest == null)
            return new ArrayList<Node>();
        return this.forest.rootNodes();
    }
}

</pre>
<div class="belt">
  <h3><a name="SpiroView" href="../TestSpecification/index.html#SpiroView">SpiroView (ビュー)</a></h3>
</div>
<pre>
package forest;

import java.awt.Graphics;
import java.awt.Dimension;
import java.awt.Point;
import mvc.View;

/**
 * 樹状整列におけるMVCのビュー (V) を担うクラスになります。
 */
public class SpiroView extends View {

    /**
     * このクラスのインスタンスを生成するコンストラクタです。
     * 
     * @param aModel モデル (Modelのインスタンス)
     */
    public SpiroView(SpiroModel aModel) {
        super(aModel, new SpiroController());
    }

    /**
     * このパネル(ビュー) の描画が必要になったときに動作するメソッドです。
     * 
     * @param aGraphics グラフィクス (描画コンテクスト)
     */
    @Override
    public void paintComponent(Graphics aGraphics) {
        // 1. 背景を塗りつぶします。
        aGraphics.setColor(this.getBackground());
        aGraphics.fillRect(0, 0, this.getWidth(), this.getHeight());

        SpiroModel aModel = (SpiroModel) this.model;
        if (aModel == null)
            return;
        Forest forest = aModel.forest();
        if (forest == null)
            return;

        // 2. スクロール量を考慮して描画の原点をずらします。
        Graphics g2 = (Graphics) aGraphics.create();

        Point scroll = this.scrollAmount();
        g2.translate(-scroll.x, -scroll.y);

        // 3. Forestオブジェクトに直接描画を委譲します。
        // これにより、レイアウト計算の途中経過が描画されます。
        forest.draw(g2);

        g2.dispose(); // コピーしたGraphicsオブジェクトを破棄します。

        // 4. Forest全体のサイズに合わせてビューの推奨サイズを設定し、
        // スクロールバーが正しく機能するようにします。
        Dimension newSize = forest.bounds().getSize();
        if (!this.getPreferredSize().equals(newSize)) {
            this.setPreferredSize(newSize);
            this.revalidate(); // レイアウトを再検証させます。
        }
    }

    /**
     * 指定された位置 (座標) にノードが存在するかを調べるメソッドです。
     * 
     * @param aPoint 位置 (ビュー座標)
     * @return ノード、もしも見つからなかった場合には、nullを応答します。
     */
    public Node whichOfNodes(Point aPoint) {
        SpiroModel aModel = (SpiroModel) this.model;
        if (aModel == null || aModel.forest() == null)
            return null;

        Point scroll = this.scrollAmount();
        Point modelPoint = new Point(aPoint.x + scroll.x, aPoint.y + scroll.y);

        return aModel.forest().whichOfNodes(modelPoint);
    }
}
</pre>
<div class="belt">
  <h3><a name="SpiroController" href="../TestSpecification/index.html#SpiroController">SpiroController (コントローラ)</a></h3>
</div>
<pre>
package forest;

import java.awt.Point;
import java.awt.event.MouseEvent;
import mvc.Controller;

/**
 * 樹状整列におけるMVCのコントローラ (C) を担うクラスになります。
 */
public class SpiroController extends Controller {

    /**
     * このクラスのインスタンスを生成するコンストラクタです。
     */
    public SpiroController() {
        super();
    }

    /**
     * マウスのボタンをクリックしたときに動作するメソッドです。
     * 
     * @param aMouseEvent マウスイベント
     */
    @Override
    public void mouseClicked(MouseEvent aMouseEvent) {
        Point aPoint = aMouseEvent.getPoint();
        SpiroView aView = (SpiroView) super.view;
        Node aNode = aView.whichOfNodes(aPoint);

        if (aNode != null) {
            System.out.println("Clicked on: " + aNode.getName());
        }

        // クリックされたらアニメーションを再度実行する
        SpiroModel aModel = (SpiroModel) super.model;
        if (aModel != null) {
            aModel.animate();
        }
    }
}
</pre>
<div class="belt">
  <h3><a name="Forest" href="../TestSpecification/index.html#Forest">Forest (フォレスト)</a></h3>
</div>
<pre>
package forest;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

/**
 * 樹状整列におけるフォレスト (木・林・森・亜格子状の森)を担うクラス。
 */
public class Forest {

    /**
     * ノード(節)群(たち)を記憶するフィールド。
     */
    private ArrayList<Node> nodes;

    /**
     * ブランチ(枝) 群(たち)を記憶するフィールド。
     */
    private ArrayList<Branch> branches;

    /**
     * 樹状整列したフォレスト (森)の領域 (矩形)を記憶するフィールド。
     */
    private Rectangle bounds;

    /**
     * このクラスのインスタンスを生成するコンストラクタ。
     */
    public Forest() {
        this.nodes = new ArrayList<>();
        this.branches = new ArrayList<>();
        this.bounds = new Rectangle(0, 0, 0, 0);
    }

    /**
     * ブランチ(枝)を追加するメソッド。
     * 
     * @param aBranch ブランチ (枝)
     */
    public void addBranch(Branch aBranch) {
        this.branches.add(aBranch);
    }

    /**
     * ノード(節)を追加するメソッド。
     * 
     * @param aNode ノード (節)
     */
    public void addNode(Node aNode) {
        this.nodes.add(aNode);
    }

    /**
     * 樹状整列するトップ (一番上位)のメソッド。
     */
    public void arrange() {
        this.arrange(null);
    }

    /**
     * 樹状整列するセカンドレベル(二番階層) のメソッド。
     * 
     * @param aModel モデル
     */
    public void arrange(SpiroModel aModel) {
        Integer counter = 0;
        for (Node node : this.nodes) {
            Integer height = node.getExtent().y + Constants.Margin.y + Constants.Interval.y;
            node.setStatus(Constants.UnVisited);
            node.setLocation(new Point(0, height * counter++));
        }

        Point aPoint = new Point(0, 0);
        ArrayList<Node> rootNodes = this.rootNodes();
        for (Node node : rootNodes) {
            Point secondPoint = this.arrange(node, aPoint, aModel);
            aPoint = new Point(0, secondPoint.y + Constants.Interval.y);
        }
        this.flushBounds();
    }

    /**
     * 樹状整列する再帰レベル (N番階層) のメソッド。
     * 
     * @param aNode  ノード
     * @param aPoint ノードの位置(座標)
     * @param aModel モデル (nullのときはアニメーションを行わない)
     * @return 樹状整列に必要だった大きさ(幅と高さ)
     */
    protected Point arrange(Node aNode, Point aPoint, SpiroModel aModel) {
        aNode.setStatus(Constants.Visited);
        aNode.setLocation(aPoint);
        this.propagate(aModel);

        Point extent = aNode.getExtent();
        ArrayList<Node> subNodes = this.sortNodes(this.subNodes(aNode));

        // 子ノードがいない場合（ベースケース）
        if (subNodes.isEmpty()) {
            Integer width = aPoint.x + extent.x;
            Integer height = aPoint.y + extent.y;
            return new Point(width, height);
        }

        // 再帰ステップ
        Integer width = aPoint.x + extent.x;
        Integer height = aPoint.y;
        Integer x = width + Constants.Interval.x;
        Integer y = height;
        Integer top = height; // サブツリーの上端を記録

        for (Node subNode : subNodes) {
            if (subNode.getStatus() == Constants.UnVisited) {
                // 再帰呼び出しから返ってくるのは、サブツリーの右下の絶対座標
                Point subTreeBounds = this.arrange(subNode, new Point(x, y), aModel);

                // y座標は、これまで配置したサブツリーの中で最も低い位置を記録する
                Integer currentBottom = y + subNode.getExtent().y;
                y = subTreeBounds.y > currentBottom ? subTreeBounds.y : currentBottom;

                // 全体の幅と高さを更新
                width = subTreeBounds.x > width ? subTreeBounds.x : width;
                height = subTreeBounds.y > height ? subTreeBounds.y : height;

                // 次のサブツリーの開始位置のために、y座標に間隔を加える
                y = y + Constants.Interval.y;
            }
        }

        y = y - Constants.Interval.y; // 最後の間隔を削除

        // 親ノードを、子ノード群の垂直方向の中心に再配置する
        Integer parentHeight = aNode.getExtent().y;
        if (y > (aPoint.y + parentHeight)) {
            Integer middleY = top + ((y - top - parentHeight) / 2);
            aNode.setLocation(new Point(aPoint.x, middleY));
            this.propagate(aModel);
        }

        height = height > parentHeight ? height : parentHeight;

        return new Point(width, height);
    }

    /**
     * フォレスト(木・林・森・亜格子状の森) の領域 (矩形)を応答するメソッド。
     * 
     * @return フォレスト領域 (矩形)
     */
    public Rectangle bounds() {
        this.bounds = new Rectangle();
        this.nodes.forEach(aNode -> this.bounds.add(aNode.getBounds()));
        return this.bounds;
    }

    /**
     * フォレスト(木・林・森・亜格子状の森)を描画するメソッド。
     * 
     * @param aGraphics グラフィクス (描画コンテクスト)
     */
    public void draw(Graphics aGraphics) {
        for (Branch branch : this.branches) {
            branch.draw(aGraphics);
        }
        for (Node node : this.nodes) {
            node.draw(aGraphics);
        }
    }

    /**
     * フォレスト(木・林・森・亜格子状の森)の領域 (矩形)を水に流す(チャラにする) メソッド。
     */
    public void flushBounds() {
        this.bounds = new Rectangle(0, 0, Constants.Margin.x, Constants.Margin.y);
    }

    /**
     * チックタックの間、スリープし、モデルが変化した、と騒ぐ(広める: 放送する) メソッド。
     * 
     * @param aModel モデル
     */
    protected void propagate(SpiroModel aModel) {
        try {
            Thread.sleep(Constants.SleepTick);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (aModel != null) {
            aModel.changed();
        }
    }

    /**
     * フォレストの根元 (ルート)となるノード群を応答するメソッド。
     * 
     * @return ルートノード群
     */
    public ArrayList<Node> rootNodes() {
        ArrayList<Node> roots = new ArrayList<>();
        for (Node aNode : this.nodes) {
            if (this.superNodes(aNode).isEmpty()) {
                roots.add(aNode);
            }
        }
        return roots;
    }

    /**
     * 引数で指定されたノード群をノード名でソート (並び替えを)するメソッド。
     * 
     * @param nodeCollection ノード群
     * @return ソートされたノード群
     */
    protected ArrayList<Node> sortNodes(ArrayList<Node> nodeCollection) {
        Collections.sort(nodeCollection, Comparator.comparing(Node::getName));
        return nodeCollection;
    }

    /**
     * 引数で指定されたノードのサブノード群を応答するメソッド。
     * 
     * @param aNode ノード
     * @return サブノード群
     */
    public ArrayList<Node> subNodes(Node aNode) {
        ArrayList<Node> subs = new ArrayList<>();
        for (Branch aBranch : this.branches) {
            if (aBranch.start().equals(aNode)) {
                subs.add(aBranch.end());
            }
        }
        return subs;
    }

    /**
     * 引数で指定されたノードのスーパーノード群を応答するメソッド。
     * 
     * @param aNode ノード
     * @return スーパーノード群
     */
    public ArrayList<Node> superNodes(Node aNode) {
        ArrayList<Node> supers = new ArrayList<>();
        for (Branch aBranch : this.branches) {
            if (aBranch.end().equals(aNode)) {
                supers.add(aBranch.start());
            }
        }
        return supers;
    }

    /**
     * 自分自身を文字列に変換するメソッドです。
     * 
     * @return 自分自身を表す文字列
     */
    @Override
    public String toString() {
        return "[Forest=" + this.nodes.size() + " nodes, " + this.branches.size() + " branches]";
    }

    /**
     * 指定された位置(座標)にノードが存在するかを調べるメソッドです。
     * 
     * @param aPoint 位置 (モデル座標)
     * @return ノード、もしも見つからなかった場合には、nullを応答します。
     */
    public Node whichOfNodes(Point aPoint) {
        // 描画が後になるもの（手前にあるもの）から探索
        for (int i = this.nodes.size() - 1; i >= 0; i--) {
            Node node = this.nodes.get(i);
            if (node.getBounds().contains(aPoint)) {
                return node;
            }
        }
        return null;
    }
}

</pre>
<div class="belt">
  <h3><a name="Branch" href="../TestSpecification/index.html#Branch">Branch (ブランチ)</a></h3>
</div>
<pre>
package forest;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Point;

/**
 * 樹状整列におけるブランチ (枝) を担うクラス。
 */
public class Branch {

    /**
     * ブランチ(枝)の始点となるノードを記憶するフィールド。
     */
    private Node start;

    /**
     * ブランチ(枝)の終点となるノードを記憶するフィールド。
     */
    private Node end;

    /**
     * このクラスのインスタンスを生成するコンストラクタ。
     * 
     * @param from ブランチ (枝) の始点となるノード
     * @param to   ブランチ (枝) の終点となるノード
     */
    public Branch(Node from, Node to) {
        super();
        this.start = from;
        this.end = to;
    }

    /**
     * ブランチ(枝)を描画するメソッド。
     * 
     * @param aGraphics グラフィクス (描画コンテクスト)
     */
    public void draw(Graphics aGraphics) {
        if (this.start == null || this.end == null)
            return;
        Graphics2D aGraphics2d = (Graphics2D) aGraphics;
        aGraphics2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        aGraphics2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

        Point startLocation = this.start.getLocation();
        Point endLocation = this.end.getLocation();
        Point startExtent = this.start.getExtent();
        Point endExtent = this.end.getExtent();

        // 始点ノードの中心下部から、終点ノードの中心上部へ線を引きます。
        Integer x1 = startLocation.x + startExtent.x;
        Integer y1 = startLocation.y + (startExtent.y / 2);
        Integer x2 = endLocation.x;
        Integer y2 = endLocation.y + (endExtent.y / 2);

        aGraphics.setColor(Constants.ForegroundColor);
        aGraphics.drawLine(x1, y1, x2, y2);
    }

    /**
     * ブランチ(枝)の終点となるノードを応答するメソッド。
     * 
     * @return 終点ノード
     */
    public Node end() {
        return this.end;
    }

    /**
     * ブランチ(枝)の始点となるノードを応答するメソッド。
     * 
     * @return 始点ノード
     */
    public Node start() {
        return this.start;
    }

    /**
     * 自分自身を文字列に変換するメソッド。
     * 
     * @return 自分自身を表す文字列
     */
    // @Override
    public String toString() {
        String startName = (this.start != null) ? this.start.getName() : "null";
        String endName = (this.end != null) ? this.end.getName() : "null";
        return "[Branch=" + startName + " -> " + endName + "]";
    }
}

</pre>
<div class="belt">
  <h3><a name="Node" href="../TestSpecification/index.html#Node">Node (ノード)</a></h3>
</div>
<pre>
package forest;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.FontMetrics;

/**
 * 樹状整列におけるノード (節)を担うクラス。
 */
public class Node extends Component {

    /**
     * ノード名:ラベル文字列を記憶するフィールド。
     */
    private String name;

    /**
     * ノードの場所(位置: 座標)を記憶するフィールド。
     */
    private Point location;

    /**
     * ノードの大きさ(幅と高さ)を記憶するフィールド。
     */
    private Point extent;

    /**
     * 樹状整列する際のノードの状態を記憶するフィールド。
     */
    private Integer status;

    /**
     * このクラスのインスタンスを生成するコンストラクタ。
     * 
     * @param aString ノード名: ラベル文字列
     */
    public Node(String aString) {
        super();
        this.name = aString;
        this.location = new Point(0, 0);
        this.status = Constants.UnKnown;
        // フォント情報を基にノードの大きさを計算
        this.setFont(Constants.DefaultFont);
        Integer width = this.stringWidth(this.name) + (Constants.Margin.x * 2);
        Integer height = this.stringHeight(this.name) + (Constants.Margin.y * 2);
        this.extent = new Point(width, height);
    }

    /**
     * ノード(節)を描画するメソッド。
     * 
     * @param aGraphics グラフィクス (描画コンテクスト)
     */
    public void draw(Graphics aGraphics) {
        Graphics2D aGraphics2D = (Graphics2D) aGraphics;
        aGraphics2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        aGraphics2D.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        // ノードの矩形を描画
        aGraphics2D.setColor(Constants.ForegroundColor);
        aGraphics2D.drawRect(this.location.x, this.location.y, this.extent.x, this.extent.y);
        // ノード名を描画
        String aString = this.getName();
        Point aPoint = (this.getBounds()).getLocation();
        aPoint.translate(Constants.Margin.x, this.extent.y - Constants.Margin.y - 2);
        // ノード（節）の名前（ラベル）描き出す。
        aGraphics2D.setFont(Constants.DefaultFont);
        aGraphics2D.drawString(aString, aPoint.x, aPoint.y);
    }

    /**
     * ノード(節)の描画領域を応答するメソッド。
     * 
     * @return ノード(節)の描画領域 (Rectangleのインスタンス)
     */
    @Override
    public Rectangle getBounds() {
        return new Rectangle(this.location, new java.awt.Dimension(this.extent.x, this.extent.y));
    }

    /**
     * ノード(節)の大きさを応答するメソッド。
     * 
     * @return ノード(節)の大きさ (幅と高さ)
     */
    public Point getExtent() {
        return this.extent;
    }

    /**
     * ノード(節)の位置を応答するメソッド。
     * 
     * @return ノード(節)の位置(座標)
     */
    @Override
    public Point getLocation() {
        return this.location;
    }

    /**
     * ノード(節)の名前を応答するメソッド。
     * 
     * @return ノード名(ラベル文字列)
     */
    @Override
    public String getName() {
        return this.name;
    }

    /**
     * ノード(節)の状態を応答するメソッド。
     * 
     * @return ノードの状態
     */
    public Integer getStatus() {
        return this.status;
    }

    /**
     * ノード(節)の大きさを設定するメソッド。
     * 
     * @param aPoint ノードの大きさ(幅と高さ)
     */
    public void setExtent(Point aPoint) {
        this.extent = aPoint;
    }

    /**
     * ノード(節)の位置を設定するメソッド。
     * 
     * @param aPoint ノードの位置(座標)
     */
    @Override
    public void setLocation(Point aPoint) {
        this.location = aPoint;
    }

    /**
     * ノード(節)の名前を設定するメソッド。
     * 
     * @param aString ノードの名前(ラベル)
     */
    @Override
    public void setName(String aString) {
        this.name = aString;
    }

    /**
     * ノード(節)の状態を設定するメソッド。
     * 
     * @param anInteger ノードの状態
     */
    public void setStatus(Integer anInteger) {
        this.status = anInteger;
    }

    /**
     * 文字列の高さを応答するメソッド。
     * 
     * @param string 文字列
     * @return 文字列の高さ
     */
    protected int stringHeight(String string) {
        FontMetrics metrics = this.getFontMetrics(this.getFont());
        return metrics.getHeight();
    }

    /**
     * 文字列の幅を応答するメソッド。
     * 
     * @param string 文字列
     * @return 文字列の幅
     */
    protected int stringWidth(String string) {
        FontMetrics metrics = this.getFontMetrics(this.getFont());
        return metrics.stringWidth(string);
    }

    /**
     * 自分自身を文字列に変換するメソッド。
     * 
     * @return 自分自身を表す文字列
     */
    // @Override
    public String toString() {
        return "[Node=" + this.name + "]";
    }
}

</pre>
<div class="belt">
  <h3><a name="forest.mf">forest.mf (マニフェストファイル)</a></h3>
</div>
<pre>
Manifest-Version: 1.0
Main-Class: forest.Example
</pre>
<div class="belt">
  <h3><a name="Makefile">Makefile (メイクファイル)</a></h3>
</div>
<pre>
</pre>
<div class="belt">
  <h3><a name="build.xml">build.xml (ビルドファイル)</a></h3>
</div>
<pre>
</pre>
<hr>
<div class="right-small">Copyright 2025 Project: software engineering II, Updated: 2025/07/30 (Created: 2025/07/27)</div>
</body>
</html>
